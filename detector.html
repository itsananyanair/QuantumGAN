<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>QuantumGAN - Faux CMS Detector</title>
<style>
  /* Fullscreen black background with subtle starfield */
  body, html {
    margin: 0; padding: 0; overflow: hidden;
    background: radial-gradient(ellipse at center, #0a0a0a 0%, #000000 90%);
    color: #eee;
    font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
  }
  #detectorCanvas {
    display: block;
    margin: 0 auto;
    background: #000;
    box-shadow: 0 0 25px #00ffe7;
    border-radius: 10px;
    max-width: 90vw; max-height: 80vh;
  }
  #controls {
    text-align: center;
    margin: 15px auto;
  }
  label {
    margin-right: 20px;
    font-weight: bold;
    cursor: pointer;
  }
  input[type=range] {
    width: 250px;
    vertical-align: middle;
  }
  #energyInput {
    width: 80px;
    font-weight: bold;
  }
  #status {
    margin-top: 10px;
    font-size: 1rem;
    color: #00ffe7;
  }
</style>
</head>
<body>

<h2 style="text-align:center; margin-top:15px;">QuantumGAN Faux CMS Detector Animation</h2>

<div id="controls">
  <label for="energyInput">Collision Energy (TeV): </label>
  <input type="number" id="energyInput" min="0.5" max="14" step="0.1" value="7" />
  
  <label><input type="checkbox" id="showTracks" checked /> Show Tracks</label>
  <label><input type="checkbox" id="showLabels" checked /> Show Particle Labels</label>
</div>

<canvas id="detectorCanvas" width="800" height="600" aria-label="Detector visualization"></canvas>
<div id="status"></div>

<script>
// Detector animation script

(() => {
  const canvas = document.getElementById('detectorCanvas');
  const ctx = canvas.getContext('2d');

  let width = canvas.width;
  let height = canvas.height;
  const centerX = width / 2;
  const centerY = height / 2;

  const particles = [];
  const particleTypes = ['Electron', 'Muon', 'Pion', 'Photon', 'Kaon', 'Proton', 'Neutrino'];
  const colors = {
    Electron: '#4ade80',
    Muon: '#22d3ee',
    Pion: '#facc15',
    Photon: '#f87171',
    Kaon: '#a78bfa',
    Proton: '#f472b6',
    Neutrino: '#9ca3af'
  };

  let showTracks = true;
  let showLabels = true;

  const maxTracks = 50;

  // Utility: random float between min and max
  function randRange(min, max) {
    return Math.random() * (max - min) + min;
  }

  // Particle class
  class Particle {
    constructor(type, energy, angle) {
      this.type = type;
      this.energy = energy; // In GeV
      this.angle = angle;   // radians
      this.radius = 0;      // track radius from center
      this.speed = 1 + energy / 50; // speed proportional to energy
      this.trackLength = randRange(200, 350);
      this.color = colors[type] || '#fff';
    }
    update() {
      this.radius += this.speed;
      if (this.radius > this.trackLength) {
        this.radius = 0; // reset track to simulate new collision event
      }
    }
    draw(ctx) {
      const x = centerX + this.radius * Math.cos(this.angle);
      const y = centerY + this.radius * Math.sin(this.angle);

      // Track line
      if (showTracks) {
        ctx.strokeStyle = this.color;
        ctx.lineWidth = 2;
        ctx.beginPath();
        ctx.moveTo(centerX + (this.radius - this.speed) * Math.cos(this.angle),
                   centerY + (this.radius - this.speed) * Math.sin(this.angle));
        ctx.lineTo(x, y);
        ctx.stroke();
      }

      // Particle head
      ctx.fillStyle = this.color;
      ctx.beginPath();
      ctx.arc(x, y, 6, 0, 2 * Math.PI);
      ctx.fill();

      // Label
      if (showLabels) {
        ctx.font = '12px Consolas, monospace';
        ctx.fillStyle = '#00ffe7';
        ctx.fillText(`${this.type} (${this.energy.toFixed(1)} GeV)`, x + 8, y - 8);
      }
    }
  }

  // Generate particles based on input energy (TeV)
  function generateParticles(energyTeV) {
    particles.length = 0; // clear existing
    const nParticles = Math.floor(randRange(15, maxTracks));
    for (let i = 0; i < nParticles; i++) {
      // Particle energy roughly proportional to collision energy, but randomized
      let eGeV = randRange(0.1, energyTeV * 1000 / 2); // convert TeV to GeV
      const type = particleTypes[Math.floor(Math.random() * particleTypes.length)];
      const angle = Math.random() * 2 * Math.PI;
      particles.push(new Particle(type, eGeV, angle));
    }
  }

  // Main animation loop
  function animate() {
    ctx.clearRect(0, 0, width, height);

    // Draw circular detector layers
    for (let r = 50; r <= 300; r += 50) {
      ctx.strokeStyle = '#004040';
      ctx.lineWidth = 1;
      ctx.beginPath();
      ctx.arc(centerX, centerY, r, 0, 2 * Math.PI);
      ctx.stroke();
    }

    // Draw particles
    particles.forEach(p => {
      p.update();
      p.draw(ctx);
    });

    requestAnimationFrame(animate);
  }

  // Event handlers for controls
  document.getElementById('energyInput').addEventListener('input', (e) => {
    const val = parseFloat(e.target.value);
    if (val >= 0.5 && val <= 14) {
      generateParticles(val);
      document.getElementById('status').textContent = `Collision simulated at ${val} TeV energy.`;
    }
  });

  document.getElementById('showTracks').addEventListener('change', (e) => {
    showTracks = e.target.checked;
  });

  document.getElementById('showLabels').addEventListener('change', (e) => {
    showLabels = e.target.checked;
  });

  // Initialize
  generateParticles(7);
  animate();

})();
</script>

</body>
</html>
